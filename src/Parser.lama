-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]);
fun opParsing(op) {
  [s(op), fun(l, k, r) { Binop(op, l, r) }]
}

var exp = memo $ expr (
  {
    [Left, {opParsing("!!")}],
    [Left, {opParsing("&&")}],
    [Nona, {opParsing("=="), opParsing("!="), opParsing(">="), opParsing(">"), opParsing("<"), opParsing("<=")}],
    [Left, {opParsing("+"), opParsing("-")}],
    [Left, {opParsing("*"), opParsing("/"), opParsing("%")}]
  }, 
  primary
);

var stmtPremitive = memo $ eta syntax (
  kSkip { Skip }                               |
  v=lident s[":="] e=exp { Assn(v, e) }        |
  kRead s["("] x=lident s[")"] { Read(x) }   |
  kWrite s["("] x=exp s[")"] { Write(x) } 
);

var stmt = memo $ eta syntax(
  s1=stmtPremitive s[";"] s2=stmt { Seq(s1, s2) } |
  stmtPremitive
);
   
-- Public top-level parser
public parse = stmt;
             